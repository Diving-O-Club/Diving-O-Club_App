\chapter{Déploiement et CI/CD}

\section{Containerisation avec Docker}

La containerisation constitue un élément essentiel de l’architecture de \textit{Diving O Club}. Elle permet d’isoler chaque service de l’application — frontend, backend, base de données PostgreSQL et base MongoDB dédiée aux logs — dans des environnements reproductibles, indépendants du système hôte et adaptés au déploiement continu. Docker garantit que l’application se comporte de manière identique en développement, en test et en production, ce qui réduit notablement les erreurs liées aux différences d’environnement.

\subsection{Objectifs de la containerisation}

La containerisation au sein de \textit{Diving O Club} répond à plusieurs besoins opérationnels :

\begin{itemize}
    \item \textbf{Standardisation des environnements} : chaque service dispose de sa propre image Docker (NestJS, Next.js, PostgreSQL, MongoDB), éliminant les problèmes de compatibilité ou de configuration manquante.
    \item \textbf{Facilitation du déploiement} : les conteneurs sont versionnés et orchestrés via Docker Compose, permettant une montée en production rapide et contrôlée.
    \item \textbf{Isolation des services} : les dépendances du backend, du frontend et des bases de données sont strictement séparées.
    \item \textbf{Préparation à la scalabilité} : la séparation des services permet une montée en charge indépendante, comme le redimensionnement du backend sans impacter le frontend ou la base de données.
    \item \textbf{Sécurisation du multi-tenant} : chaque club dispose de données isolées dans PostgreSQL, tandis que MongoDB stocke les logs applicatifs de manière indépendante.
\end{itemize}

\subsection{Structure des services Docker}

La stack applicative repose sur quatre conteneurs principaux :

\begin{itemize}
    \item \textbf{frontend} : application Next.js servant l’interface utilisateur.
    \item \textbf{backend} : API NestJS contenant la logique métier et accédant à PostgreSQL via Prisma.
    \item \textbf{postgres} : base relationnelle contenant les données critiques (comptes utilisateurs, clubs, événements, paiements, documents, etc.).
    \item \textbf{mongodb} : base documentaire permettant le stockage des logs et événements techniques.
\end{itemize}

L’ensemble est orchestré via un fichier \texttt{docker-compose.yml} qui gère les réseaux, les volumes persistants et les variables d’environnement nécessaires aux services.

\subsection{Processus de construction des images}

Chaque service dispose d’un \textit{Dockerfile} dédié.

\paragraph{Backend NestJS}
L’image du backend est construite à partir d’une image Node. Les dépendances sont installées, le code TypeScript est compilé et le client Prisma est généré. Cette image inclut la logique métier ainsi que les scripts nécessaires aux migrations.

\paragraph{Frontend Next.js}
L’image du frontend génère un build optimisé pour la production, ensuite servi via un serveur Next autonome. Cette approche assure des performances constantes et une compatibilité totale avec la CI/CD.

\paragraph{Bases de données}
Les services PostgreSQL et MongoDB reposent sur des images officielles configurées via des variables d’environnement. Des volumes Docker garantissent la persistance des données, y compris lors du redémarrage ou du remplacement des conteneurs.

\subsection{Bénéfices pour le cycle de développement}

\begin{itemize}
    \item \textbf{Onboarding simplifié} : un nouveau contributeur peut démarrer l’environnement complet avec une seule commande : \texttt{docker compose up --build}.
    \item \textbf{Tests reproductibles} : les tests d’intégration, de performance et end-to-end utilisent les mêmes conteneurs que la production.
    \item \textbf{Clarté architecturale} : la correspondance entre les conteneurs et les tiers applicatifs reflète fidèlement l’architecture de \textit{Diving O Club}.
    \item \textbf{Intégration transparente avec la CI/CD} : GitHub Actions construit et valide les images Docker, garantissant l’absence d’écart entre l’environnement testé et la version déployée.
\end{itemize}


\section{Pipeline CI/CD avec GitHub Actions}

L’intégration continue (CI) et le déploiement continu (CD) jouent un rôle déterminant dans la qualité et la fiabilité de \textit{Diving O Club}. Grâce à GitHub Actions, chaque modification apportée au code déclenche automatiquement des vérifications, des tests et, selon la branche ciblée, la construction et la préparation des images Docker pour le déploiement. Ce pipeline garantit que seule une version conforme, testée et stable peut progresser vers les environnements de préproduction ou de production.

\subsection{Objectifs du pipeline CI/CD}

La mise en place d’un pipeline CI/CD répond à plusieurs enjeux essentiels :

\begin{itemize}
    \item \textbf{Automatisation des tests} : chaque push ou pull request déclenche l’exécution des tests unitaires, d’intégration et de vérification statique (lint).
    \item \textbf{Qualité du code} : GitHub Actions empêche l’intégration d’une modification non conforme, réduisant les risques de régression.
    \item \textbf{Déploiement contrôlé} : seules les versions validées sur la branche \texttt{develop} peuvent être fusionnées vers \texttt{main}, déclenchant la génération des images Docker stables.
    \item \textbf{Reproductibilité} : les builds produits par la CI sont identiques à ceux utilisés sur l’environnement de production.
    \item \textbf{Suivi transparent} : chaque étape du pipeline est historisée et consultable directement depuis GitHub.
\end{itemize}

\subsection{Structure du pipeline GitHub Actions}

Le pipeline CI/CD de \textit{Diving O Club} repose sur plusieurs workflows distincts mais complémentaires :

\begin{itemize}
    \item \textbf{workflow CI (pull requests vers develop)} : vérification du linting, installation des dépendances, exécution des tests backend (NestJS) et frontend (Next.js), ainsi que la compilation de l'application.
    \item \textbf{workflow de build Docker} : construction des images backend et frontend pour s’assurer que les Dockerfiles restent valides à chaque modification.
    \item \textbf{workflow CD (push sur main)} : génération d’une version stable, construction et push des images Docker versionnées, préparation du déploiement vers l’environnement cible.
\end{itemize}

Chaque workflow est exécuté dans un environnement Linux virtualisé fourni par GitHub (\texttt{ubuntu-latest}), garantissant un comportement homogène.

\subsection{Étapes clés du pipeline}

\paragraph{1. Vérification du code}
Le pipeline effectue systématiquement :
\begin{itemize}
    \item l’analyse statique du code JavaScript/TypeScript (ESLint),
    \item la vérification du style de code,
    \item l’installation propre des dépendances.
\end{itemize}

\paragraph{2. Exécution des tests}
Les tests du projet sont exécutés automatiquement :
\begin{itemize}
    \item \textbf{backend} : tests unitaires et d’intégration via Jest,
    \item \textbf{frontend} : tests unitaires avec Jest et React Testing Library.
\end{itemize}

Si un test échoue, la pull request ne peut pas être fusionnée.

\paragraph{3. Construction des images Docker}
Le pipeline reconstruit les images du backend NestJS et du frontend Next.js afin de garantir leur compatibilité avec les environnements de production. Cette étape vérifie notamment :
\begin{itemize}
    \item la validité des Dockerfiles,
    \item la réussite du build Next.js,
    \item la compilation du backend.
\end{itemize}

\paragraph{4. Versioning et déploiement automatisé}
Lorsqu’un commit est fusionné dans la branche \texttt{main}, GitHub Actions déclenche automatiquement :
\begin{itemize}
    \item la création d’un tag de version (par exemple \texttt{v1.4.0}),
    \item la construction des images Docker associées,
    \item leur publication dans un registre d’images (Docker Hub ou GitHub Container Registry),
    \item la préparation du déploiement sur l’environnement de production.
\end{itemize}

Ce processus garantit que seules les versions validées et traçables atteignent les serveurs.

\subsection{Bénéfices pour le projet}

\begin{itemize}
    \item \textbf{Fiabilité accrue} : chaque livraison est vérifiée automatiquement, réduisant les erreurs humaines.
    \item \textbf{Cycle de développement accéléré} : le temps passé à valider et tester manuellement est considérablement réduit.
    \item \textbf{Transparence totale} : chaque étape (tests, builds, déploiements) est archivée dans GitHub.
    \item \textbf{Alignement avec les standards professionnels} : l'utilisation d’un pipeline CI/CD démontre une maîtrise des pratiques DevOps attendues dans le cadre du titre CDA.
    \item \textbf{Préparation à la montée en charge} : le pipeline permet d’enchaîner les releases rapidement, en toute sécurité.
\end{itemize}


\section{Documentation et monitoring}

Une documentation claire et un système de monitoring fiable sont indispensables pour garantir la maintenabilité, la transparence et la stabilité de \textit{Diving O Club}. Ces deux aspects complètent la containerisation et le pipeline CI/CD en offrant une visibilité complète sur l’état de la plateforme ainsi qu’une compréhension partagée du fonctionnement interne de l’application. Ils permettent également d’anticiper les erreurs, de faciliter l’arrivée de nouveaux contributeurs et d’assurer le contrôle qualité demandé dans le cadre du titre CDA.

\subsection{Documentation du projet}

La documentation du projet couvre à la fois l’usage fonctionnel de l’application et les aspects techniques nécessaires au développement, au déploiement et à la maintenance.

\paragraph{Documentation fonctionnelle}
Elle présente le parcours utilisateur, les fonctionnalités clés (gestion des membres, inscriptions, certificats médicaux, événements, paiements, etc.) ainsi que les règles métier associées. Cette documentation facilite la compréhension du produit par les membres du club pilote, les encadrants, ainsi que par les utilisateurs finaux.

\paragraph{Documentation technique}
La documentation technique fournit une vision détaillée de l’architecture et des choix technologiques :
\begin{itemize}
    \item architecture 3 tiers (frontend, backend, base de données),
    \item description des services (NestJS, Next.js, PostgreSQL, MongoDB),
    \item conventions de développement,
    \item gestion des environnements,
    \item schémas UML, MCD, séquences et API REST,
    \item procédures de déploiement et d’utilisation de Docker.
\end{itemize}

Elle inclut également la description des endpoints avec leurs paramètres, formats JSON et statuts HTTP. Cette documentation API facilite l’intégration avec d’autres services, notamment HelloAsso dans les futures versions.

\paragraph{Documentation automatisée}
Le backend NestJS utilise un système de génération automatique de documentation à l’aide de Swagger/OpenAPI. Chaque modification apportée aux contrôleurs ou DTOs met automatiquement à jour la documentation interactive de l’API. Cela garantit :
\begin{itemize}
    \item une documentation toujours synchronisée avec le code,
    \item une meilleure communication entre développeurs,
    \item des tests manuels simplifiés via l’interface Swagger.
\end{itemize}

\subsection{Monitoring et suivi de l’application}

Le monitoring permet d’observer en temps réel la santé du système, la performance des services et les comportements anormaux. Pour \textit{Diving O Club}, plusieurs niveaux de surveillance ont été mis en place.

\paragraph{Centralisation des logs}
Les logs techniques sont stockés dans MongoDB, séparée de PostgreSQL. Cette approche permet :
\begin{itemize}
    \item de conserver un historique complet des événements back-end,
    \item d’analyser les erreurs, temps de réponse et anomalies,
    \item de faciliter le débogage et la compréhension du comportement applicatif.
\end{itemize}

Des logs sont générés pour :
\begin{itemize}
    \item les actions critiques (connexion, création d’événement, paiement, document médical),
    \item les erreurs de validation ou de base de données,
    \item les performances des services,
    \item la consommation mémoire et CPU des conteneurs.
\end{itemize}

\paragraph{Monitoring des performances}
Des outils comme \textbf{Lighthouse} (performance frontend) et \textbf{Wave} (accessibilité) sont utilisés pour mesurer :
\begin{itemize}
    \item le temps de chargement du frontend,
    \item la performance mobile, essentielle pour une PWA,
    \item l’accessibilité générale pour les utilisateurs,
    \item les best practices SEO et PWAs.
\end{itemize}

Les résultats Lighthouse permettent d’ajuster la configuration Next.js, réduire la taille des bundles ou optimiser les images.

\paragraph{Surveillance de l’infrastructure}
Dans le cadre du déploiement conteneurisé, l'état des services Docker est suivi via :
\begin{itemize}
    \item l’inspection de l’usage CPU/mémoire,
    \item la vérification des volumes persistants,
    \item la surveillance du réseau entre les services.
\end{itemize}

Ce suivi garantit que la plateforme reste stable même pendant les périodes de forte activité (inscriptions, renouvellement d’adhésions, événements clubs).

\subsection{Bénéfices pour la maintenance et l’évolution}

\begin{itemize}
    \item \textbf{Réduction du temps de résolution des bugs} : les logs centralisés permettent d’identifier rapidement la cause d'un problème.
    \item \textbf{Meilleure qualité produit} : Lighthouse et Wave fournissent des axes d’amélioration concrets pour l’UX, la performance et l’accessibilité.
    \item \textbf{Standardisation du travail d’équipe} : la documentation technique partagée facilite la contribution de nouveaux développeurs.
    \item \textbf{Préparation aux futures versions} : une base documentée et monitorée simplifie l’intégration de nouvelles fonctionnalités (multi-tenant, dashboard avancé, statistiques, etc.).
    \item \textbf{Conformité aux bonnes pratiques du titre CDA} : le projet démontre une démarche complète de qualité logicielle, de supervision et de documentation.
\end{itemize}


\section{Liens utiles}

\begin{itemize}
    \item Dockerfile reference: \url{https://docs.docker.com/reference/dockerfile/}
    \item Docker Compose: \url{https://docs.docker.com/compose/}
    \item GitHub Actions: \url{https://docs.github.com/actions}
    \item Postman: \url{https://learning.postman.com/docs/getting-started/introduction/}
    \item Prometheus: \url{https://prometheus.io/docs/}
\end{itemize}
